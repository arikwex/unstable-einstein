<html><title>SHUTTLEDECK</title><link rel="shortcut icon" type="image/x-icon" href="images/favicon.ico" sizes="64x64"/><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><style>canvas{width:100%;height:100%;}body{margin:0;background:#000;}</style><canvas><script>const canvas = document.getElementsByTagName('canvas')[0];
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.lineCap='round';
ctx.lineJoin='round';

var w, h;
function width() { return w; }
function height() { return h; }

function resize() {
  canvas.width = window.innerWidth * 1;
  canvas.height = window.innerHeight * 1;
  w = canvas.width;
  h = canvas.height;
}resize();
window.addEventListener('resize', resize);

// list of all active game objects
var g = [];

function get() { return g }
function add(obj) { g.push(obj); }
function remove(obj) { g = g.filter((x) => x != obj); }
function clear(obj) { g = []; }

function e() {
  var HANDLES = {};

  return {
    clear: () => HANDLES = {},
    on: (e, handler) => (HANDLES[e] || (HANDLES[e] = [])).push(handler),
    off: (e, handler) => (HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler)),
    emit: (e, data) => (HANDLES[e] || []).forEach((handler) => handler(data)),
  };
}

// Create global event bus from event emitter
b = new e();
var bus = b;

function pulse(fn, min, max, period) {
  var anim = 0;
  return (dT) => {
    anim += dT;
    fn((Math.sin(anim / period * 6.3) + 1) / 2 * (max - min) + min);
  }
}
function transition$1(duration, fadeOut) {
  var anim = 0;
  this.update = (dT) => {
    anim += dT / duration;
    if (anim > 1 && fadeOut) {
      this.destroyed = true;
      bus.emit('txn-done');
    }
  };
  this.render = (ctx) => {
    var w = width();
    var h = height();
    var tf = 0;
    if (fadeOut) { tf = Math.max(1-anim*anim, 0); }
    else { tf = Math.pow(Math.max(anim-0.3, 0)*1.3, 2);}
    // Top plate
    ctx.save();
    ctx.fillStyle = '#343';
    ctx.translate(0, -h*0.6 * tf);
    ctx.fillRect(0, 0, w, h/2);
    ctx.strokeStyle = '#7f7';
    ctx.fillStyle = '#7f7';
    ctx.lineWidth = w * 0.03;
    ctx.fillRect(0,h/2,w,h*0.05);
    ctx.strokeRect(w*0.25, h*0.2, w*0.5, h*0.2);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font=`${w*0.05}px monospace`;
    ctx.fillText('UNSTABLE',w*0.5,h*0.27);
    ctx.fillText('EINSTEIN',w*0.5,h*0.33);
    ctx.restore();

    // Bottom plate
    ctx.save();
    ctx.fillStyle = '#343';
    ctx.translate(0, h*0.6 * tf);
    ctx.fillRect(0, h/2, w, h/2);
    ctx.fillStyle = '#7f7';
    ctx.fillRect(0,h*0.55,w,-h*0.05);
    ctx.restore();
  };
}

function drawStars(ctx, x, y, vx, vy) {
  const w = width();
  const h = height();
  const N = Math.sqrt(w * h) / 10;
  ctx.beginPath();
  ctx.strokeStyle = '#aaa';
  ctx.fillStyle = '#ddd';
  ctx.lineWidth = 0.5;
  for (let i = 0; i < N; i++) {
    let s = 1 + (Math.sin(i * i * 1217 + i * i * i * 983) * 0.5 + 0.5) * 5;
    let ax = (1234918 * i * i + i * i * i * i * 2291722 + x * s) % (w+100)-50;
    let ay = (3000182 * i * i * i * i + i * i * i * i * i * 500291 + y * s) % (h+100)-50;
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax+vx*s, ay+vy*s);
    ctx.fillRect(ax-1, ay-1, 2, 2);
  }
  ctx.stroke();
}

function drawCharPlayer(ctx) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(s*1.2, h + Math.sin(Date.now()*0.003)*s*0.1);
  // Torso
  ctx.fillStyle='#bbb';
  ctx.beginPath();
  ctx.arc(-s*0.1, s*0.1, s*1.4, 0, 6.29);
  ctx.fill();
  // Head
  ctx.fillStyle='#eee';
  ctx.beginPath();
  ctx.arc(0, -s*1.9, s, 0, 6.29);
  ctx.fill();
  // Visor
  ctx.fillStyle='#3af';
  ctx.fillRect(-s*0.1,-s*2.1,s,s*0.4);
  ctx.restore();
}

function drawCharZoren(ctx, col='#3b5') {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  ctx.save();
  ctx.translate(w-s*1.2, h+Math.sin(Date.now()*0.0021+3)*s*0.1);
  // Torso
  ctx.fillStyle=col;//'#8a8';
  ctx.fillRect(-s*0.5,-s*1.5,s*1.4,s*2);
  ctx.fillStyle='#666';
  ctx.fillRect(-s*0.2,-s*1.5,s*0.1,s*2);
  ctx.fillRect(-s*0.35,-s*0.8,s*0.1,s*0.1);
  ctx.fillRect(-s*0.35,-s*0.6,s*0.1,s*0.1);
  // Head
  ctx.fillStyle='#fdb';
  ctx.beginPath();
  ctx.arc(0, -s*1.8, s, 0, 6.29);
  ctx.fill();
  // Glasses
  ctx.fillStyle='#333';
  ctx.fillRect(-s*1,-s*1.95,s*1.6,s*0.1);
  ctx.fillStyle=col;
  ctx.beginPath();
  ctx.arc(-s*0.8,-s*1.8,s*0.3,0,6.29);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s*0.1,-s*1.8,s*0.3,0,6.29);
  ctx.fill();
  ctx.restore();
}

var lineBreaks = (ctx, txt, maxWidth) => {
  var str = '';
  var lines = [];
  for (let i = 0; i < txt.length; i++) {
    str += txt[i];
    if (ctx.measureText(str).width > maxWidth) {
      var ls = str.lastIndexOf(' ');
      var ps = str.substring(0, ls);
      lines.push(ps.trim());
      str = str.substring(ls);
    }
  }
  if (str.trim().length > 0) {
    lines.push(str.trim());
  }
  return lines;
};
var getTextLines = (ctx, txt, w, h, maxWidth) => {
  var r = textLineMap[txt];
  if (r) {
    if (r.w == w && r.h == h) {
      return r.lines;
    }
  }
  var l = lineBreaks(ctx, txt, maxWidth);
  textLineMap[txt] = {w,h,lines:l};
  return l;
};
var textLineMap = {};

function drawDialogBox(ctx, title, txt) {
  var w = width();
  var h = height();
  var s = Math.min(h * 0.075, w * 0.1);
  var ts = Math.max(w * 0.09, h * 0.08);
  ctx.save();
  // Dialog box
  ctx.fillStyle = '#236';
  ctx.strokeStyle = '#3af';
  ctx.lineWidth = s * 0.1;
  ctx.beginPath();
  ctx.moveTo(s*2.8,h*0.75);
  ctx.lineTo(w-s*2.8,h*0.75);
  ctx.lineTo(w-s*2.8,h-s*1.8);
  ctx.lineTo(w-s*2.5,h-s*1.6);
  ctx.lineTo(w-s*2.8,h-s*1.4);
  ctx.lineTo(w-s*2.8,h-s*0.2);
  ctx.lineTo(s*2.8,h-s*0.2);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // title text
  ctx.fillStyle='#ff3';
  ctx.textAlign='left';
  ctx.font=`${ts*0.3}px monospace`;
  ctx.fillText(title, s*3, h*0.75+ts*0.25);

  // title text
  ctx.fillStyle='#fff';
  ctx.textAlign='left';
  ctx.font=`${ts*0.25}px monospace`;

  var lines = getTextLines(ctx, txt, w, h, w - s*6);
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], s*3, h*0.75+ts*(2.1 + i)*0.3);
  }
  // Split line text
  ctx.restore();
}

function StartButton(txt = 'Liftoff') {

  var fn = ({x, y}) => {
    var w = width();
    var uiScale = w * 0.1;
    if (x > w*0.97 - uiScale*2 && x < w*0.97 && y > 0 && y < w*0.02+uiScale*0.8) {
      bus.emit('start');
      bus.off('tap', fn);
    }
  };

  bus.on('tap', fn);

  this.render = (ctx) => {
    var w = width();
    var uiScale = w * 0.1;

    ctx.save();
    ctx.translate(w * 0.97-uiScale,w*0.02+uiScale*0.4);
    var p = (Date.now() % 500) / 500;
    var s = (1-(1-p)*(1-p)) * 0.4 + 0.8;
    ctx.scale(s,s*1.1);
    ctx.strokeStyle = '#0a0';
    ctx.lineWidth = uiScale * 0.1 * (1 - p);
    ctx.strokeRect(-uiScale, -uiScale*0.4, uiScale*2, uiScale*0.8);
    ctx.restore();

    ctx.fillStyle = '#0a0';
    ctx.fillRect(w * 0.97, w*0.02, -uiScale*2, uiScale*0.8);

    ctx.fillStyle = '#fff';
    ctx.font = `${uiScale*0.35}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(txt, w*0.97 - uiScale * 1, w*0.02+uiScale * 0.4);
  };
}

function Audio() {
  var audioCtx = null;
  var sampleRate = null;

  // Sounds to be loaded on init (cursed AudioContext waiting for interaction)
  var gateCloseSound;
  var gateOpenSound;
  var buySound;
  var mineralSound;
  var collisionSound;
  var laneSound;
  var missileSound;
  var laserSound;
  var pulseBreakerSound;
  var hopSound;
  var dashSound;
  var hyperSound;
  var healSound;
  var musicBuffer;
  var rocketBuffer;

  var sin = (i) => Math.min(Math.max(Math.sin(i), -1), 1);
  var saw = (i) => ((i % 6.28)-3.14)/6.28;
  var sqr = (i) => Math.min(Math.max(Math.sin(i) * 1000, -1), 1);
  var win = (i, ts, te) => {
    if (i<ts*44100 || i>te*44100) {return 0;}
    return 1 - ((i/44100) - ts)/(te - ts);
  };
  var note = (i, tone, time, dur) => 0.01*sqr(i / (80/Math.pow(2,tone/12))) * win(i,time,time+dur);
  var hhat = (i, time) => 0.02*Math.random() * win(i,time,time+0.06);

  var generate = (duration, fn, fading = true) => {
    var audioBuffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
    var buffer = audioBuffer.getChannelData(0);
    var N = audioBuffer.length;
    for (var i = 0; i < N; i++) {
      var p = i / N;
      var envelope = 1 - p;
      if (!fading) { envelope = 1; }
      buffer[i] = fn(i*44100/sampleRate) * envelope;
    }
    return audioBuffer;
  };

  this.init = () => {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate;

    // Transition animation - Gate whirring close
    gateCloseSound = generate(0.6, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0);
    });

    // Transition animation -  Gate whirring open + noise of steam
    gateOpenSound = generate(1, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0) + 0.1 * Math.random() * win(i, 0, 1);
    });

    // Buy an item (ding + ding)
    buySound = generate(0.7, (i) => {
      return 0.07 * (saw(i/19) * win(i, 0, 0.15) + saw(i/11) * win(i, 0.1, 0.7));
    });

    // Gain mineral blip + Siphon sound
    mineralSound = generate(0.15, (i) => {
      return 0.04 * sin(i/(15 - i / 2000));
    });

    // Collision / take damage
    collisionSound = generate(0.8, (i) => {
      return 0.1 * Math.random() * win(i, 0, 0.8) * (sqr(i/200)+1);
    });

    // Swap lane
    laneSound = generate(0.4, (i) => {
      return 0.04 * (1+Math.random()/3) * win(i, 0, 0.4) * sin(i/50);
    });

    // Kepler missile + Crazy Rockets + Nuke
    missileSound = generate(0.7, (i) => {
      return 0.04 * Math.random() * win(i, 0, 0.7) * (sqr(i/100) + 1);
    });

    // Sigma cannon / laser
    laserSound = generate(1.5, (i) => {
      return 0.08 * (sin(i/(30-i/400)) * win(i, 0, 0.15) * 3 + saw(i/60)*(sqr(i/400)+1)/2*win(i,0.1,1.5))
    });

    // Pulse breaker
    pulseBreakerSound = generate(1, (i) => {
      return 0.04 * sin(i/50)*(sqr(i/800+1)+1);
    });

    // Hop sound
    hopSound = generate(0.7, (i) => {
      return 0.1 * (
        saw(i/30) * win(i, 0, 0.1) +
        saw(i/50) * win(i, 0.1, 0.2) +
        saw(i/40) * win(i, 0.2, 0.3) +
        saw(i/20) * win(i, 0.3, 0.4) +
        saw(i/10) * win(i, 0.4, 0.5)
      );
    });

    // Dash sound
    dashSound = generate(0.7, (i) => {
      var acc = 0;
      for (let q = 0; q < 10; q++) {
        acc += sin(i/(10+q*q/20)) * win(i, q/10, (q+1)/10);
      }
      return 0.05*acc;
    });

    // Hyperdrive sound
    hyperSound = generate(1.5, (i) => {
      var acc = 0;
      for (let q = 0; q < 13; q++) {
        acc += sqr(i/(10-q*q/15)) * win(i, q/15, (q+1)/15);
        acc += sqr(i/(40-q*q/3)) * win(i, q/15+0.03, (q+1)/15);
      }
      return 0.05*acc;
    });

    // Heal sound
    healSound = generate(0.6, (i) => {
      return 0.04 * sin(i/(50-i/2000))*(sqr(i/700+1)+1);
    });

    musicBuffer = generate(0.2*48, (i) => {
      var d = 0.2;
      var acc = 0;
      for (let q = 0; q < 48; q+=8) {
        acc += hhat(i, d*(q+0))+
          hhat(i, d*(q+1))+
          hhat(i, d*(q+2))*3+
          hhat(i, d*(q+3))+
          hhat(i, d*(q+4))+
          hhat(i, d*(q+6))*3;
      }
      // Phrase 1
      acc += note(i, 12, d * 8, d * 1) +
        note(i, 7, d * 11, d * 1) +
        note(i, 10, d * 14, d * 1.5) +
        note(i, 9, d * 16, d * 1.5) +
        note(i, 3, d * 18, d * 1.5) +
        // Phrase 2
        note(i, 6, d * 32, d * 1) +
        note(i, 3, d * 35, d * 1) +
        note(i, 5, d * 38, d * 1.5) +
        note(i, 3, d * 40, d * 1.5) +
        note(i, 0, d * 42, d * 1.5);
      return acc;
    }, false);

    rocketBuffer = generate(3, (i) => {
      return 0.01 * (saw(i/300)*sqr(i/130) + 1);
    }, false);
  };

  var play = (audioBuffer) => {
    var source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    source.start();
  };

  this.setup = () => {
    if (audioCtx == null) { this.init(); }
    bus.on('txn', () => { play(gateCloseSound); });
    bus.on('txn-done', () => { play(gateOpenSound); });
    bus.on('buy', () => { play(buySound); });
    bus.on('mineral', () => { play(mineralSound); });
    bus.on('mine', () => { play(mineralSound); });
    bus.on('hit', () => { play(collisionSound); });
    bus.on('boom', () => { play(collisionSound); });
    bus.on('lane', () => { play(laneSound); });
    bus.on('hop', () => { play(hopSound); });
    bus.on('dash', () => { play(dashSound); });
    bus.on('hyper', () => { play(hyperSound); });
    bus.on('heal', () => { play(healSound); });
    bus.on('projectile', (t) => {
      if (t==1 || t==4 || t==5) {play(missileSound);}
      if (t==2) {play(laserSound);}
      if (t==3) {play(pulseBreakerSound);}
    });
  };

  var musicSource = null;
  this.music = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = musicBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.bgRocket = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = rocketBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.stopMusic = () => {
    try {
      if (musicSource != null) { musicSource.stop(); }
    } catch (e) {}
  };
}

var audio = new Audio();

function Text(str, x, y, color = '#fff', size='1', align='left') {
  this.str = str;
  this.x = x;
  this.y = y;
  this.color = color;
  this.size = size;

  this.render = (ctx) => {
    var uiScale = width() * 0.08;
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = this.color;
    ctx.font = `${this.size * uiScale}px monospace`;
    ctx.fillText(this.str, this.x(), this.y());
  };
}

function MainMenu() {
  // Title card
  add(new Text('UNSTABLE EINSTEIN', ()=>width()/2, ()=>height()*0.4, '#7f7', 1, 'center'));

  // Push to star pulser
  var pushToStart = new Text('[ Press to start ]', ()=>width()/2, ()=>height()*0.6, '#7f7', 0.5, 'center');
  pushToStart.ecs = [pulse((x) => {pushToStart.size = x;}, 0.45, 0.55, 1)];
  add(pushToStart);

  // By me :)
  add(new Text('by Ariel Wexler', ()=>width()/2, ()=>height()*0.8, '#777', 0.35, 'center'));

  // Touch anywhere to go to intro
  var fn = () => {
    transition(1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);
}

var persist = (() => {
  var minerals = 0;
  var level = 0;
  var handSize = 3;
  var maxEnergy = 5;
  var maxShield = 3;
  var deck = [];

  var a = {
    reset: () => {
      minerals = 0;
      level = 0;
      handSize = 3;
      maxEnergy = 5;
      maxShield = 3;
    },

    getMinerals: () => minerals,
    addMineral: (m) => minerals += m,

    getLevel: () => level,
    setLevel: (l) => level = l,

    getHandSize: () => handSize,
    setHandSize: (e) => handSize = e,

    getMaxEnergy: () => maxEnergy,
    setMaxEnergy: (e) => maxEnergy = e,

    getMaxShield: () => maxShield,
    setMaxShield: (e) => maxShield = e,

    getDeck: () => deck,
    addToDeck: (c) => deck.push(c),
  };
  a.reset();

  return a;
})();

function Intro() {
  add(new Text('Instructions', ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));
  add(new StartButton());
  bus.on('start', () => {
    persist.reset();
    transition(2);
  });
}

function Player(engine) {
  let x = width() * 0.2;
  let y = height() * 0.75;

  this.update = (dT) => {
  };
  this.render = (ctx) => {
    ctx.save();
    let a = Date.now() * 0.01;
    var s = engine.getScale() * 30;
    ctx.translate(x, y);
    let breath = Math.cos(a * 0.7);
    let th = -s * (1.95 + breath * 0.05);
    let tw = s * (0.5 + (1 - breath) * 0.02);
    // Body
    ctx.fillStyle = '#fff';
    ctx.fillRect(-tw, 0, 2*tw, th);
    // Hair
    ctx.beginPath();
    ctx.moveTo(s*0.5, th + 2);
    for (let i = 0; i < 10; i++) {
      let p = i / 10;
      let dx2 = Math.cos(p * 5) * (tw + s * 0.25) - s * 0.25;
      let dx = Math.cos(p * 5 + Math.cos(a+i) * 0.5) * s * 0.2 + dx2;
      let dy2 = Math.sin(p * 4.8) * s * 0.5 - s * 0.4 * p;
      let dy = Math.sin(p * 4.8) * s * 0.2 + dy2;
      ctx.lineTo(dx, th + 2 - dy);
      ctx.lineTo(dx2, th + 2 - dy2);
    }
    ctx.lineTo(-tw, th + s * 0.3);
    ctx.closePath();
    ctx.fill();
    // Glasses
    ctx.beginPath();
    ctx.fillStyle = '#7af';
    ctx.arc(tw-s*0.05,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(tw-s*0.55,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.restore();
  };
}

function Engine() {
  // Game dimensions
  const railWidth = 0.1;
  const buttonWidth = 0.15;

  // Game state
  let normalTime = true;
  let normalMatter = true;
  let normalSpace = true;

  // Game objects
  const player = new Player(this);
  add(player);

  // Touch controls
  bus.on('tap', ({x, y}) => {
    const h = height();
    const w = width();
    const th = h - buttonWidth * h;
    if (y > th && y < h) {
      if (x > 0 && x <= w / 3) {
        normalSpace = !normalSpace;
      }
      if (x > w / 3 && x <= w * 2 / 3) {
        normalMatter = !normalMatter;
      }
      if (x > w * 2 / 3 && x <= w) {
        normalTime = !normalTime;
      }
    }
  });

  this.getScale = () => {
    return width() / 800.0;
  };

  this.update = (dT) => {
  };

  this.topLimit = () => {
    let h = height();
    return railWidth * h;
  };

  this.bottomLimit = () => {
    let h = height();
    return h - (railWidth + buttonWidth) * h;
  };

  this.render = (ctx) => {
    // Screen dimensions
    const w = width();
    const h = height();
    const bh = buttonWidth * h;
    const s = Math.min(bh * 0.2, w * 0.04);

    // Bottom and top rails
    ctx.fillStyle='#000';
    ctx.fillRect(0, 0, w, this.topLimit());
    ctx.fillRect(0, this.bottomLimit(), w, railWidth * h);

    // Controls area
    ctx.fillStyle='#222';
    ctx.fillRect(0, this.bottomLimit() + railWidth * h, w, bh);

    // Space controls
    ctx.lineWidth = s * 0.3;
    if (normalSpace) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#363';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#232';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(0, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.moveTo(w / 6 - s * 1.5, bh * 0.65);
    ctx.lineTo(w / 6 - s * 0.2, bh * 0.65 - s);
    ctx.lineTo(w / 6 - s * 0.2, bh * 0.65 + s);
    ctx.lineTo(w / 6 - s * 1.5, bh * 0.65);
    ctx.moveTo(w / 6 + s * 1.5, bh * 0.65);
    ctx.lineTo(w / 6 + s * 0.2, bh * 0.65 - s);
    ctx.lineTo(w / 6 + s * 0.2, bh * 0.65 + s);
    ctx.lineTo(w / 6 + s * 1.5, bh * 0.65);
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalSpace) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Space', w / 6, bh * 0.2);
    } else {
      ctx.fillStyle = '#888';
      ctx.fillText('Stretched Space', w / 6, bh * 0.2);
    }
    ctx.restore();

    // Matter controls
    ctx.lineWidth = s * 0.3;
    if (normalMatter) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#633';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#322';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(w / 3, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.arc(w / 6, bh * 0.65, s * 1.1, 0, 6.29);
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalMatter) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Matter', w / 6, bh * 0.2);
    } else {
      ctx.fillStyle = '#888';
      ctx.fillText('Anti Matter', w / 6, bh * 0.2);
    }
    ctx.restore();

    // Time controls
    ctx.lineWidth = s * 0.3;
    if (normalTime) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#336';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#223';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(w * 2 / 3, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.moveTo(w / 6 - s, bh * 0.65 - s);
    ctx.lineTo(w / 6 + s, bh * 0.65 - s);
    ctx.lineTo(w / 6 - s, bh * 0.65 + s);
    ctx.lineTo(w / 6 + s, bh * 0.65 + s);
    ctx.closePath();
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalTime) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Time', w / 6, bh * 0.2);
    } else {
      ctx.fillStyle = '#888';
      ctx.fillText('Paused Time', w / 6, bh * 0.2);
    }
    ctx.restore();
  };
}

const planets = [
  'Tenadu',
  'Nurosto Prime',
  'Worlax',
  'Mektrov Zero',
  'Cytoxia',
  'Broggendor',
  'Voitec',
  'Helion',
  'Earth (Remnants)',
  'Yonzi Mata',
  'Streva Gateway',
  'Lumatorr',
  'Desela',
  'Korva-6'
];

function GameOver() {
  var currLevel = persist.getLevel();

  // Title card
  add(new Text('SHUTTLEDECK', ()=>width()/2, ()=>height()*0.2, '#fff', 1, 'center'));

  // Game over :(
  add(new Text('Game Over', ()=>width()/2, ()=>height()*0.35, '#f55', 1, 'center'));
  add(new Text(`Exploded approaching planet ${planets[currLevel]}`, ()=>width()/2, ()=>height()*0.6, '#f55', 0.4, 'center'));

  // Push to play again
  add(new Text('[ Press to retry ]', ()=>width()/2, ()=>height()*0.8, '#777', 0.5, 'center'));
  var fn = () => {
    transition(1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);

  // Starfield
  this.render = (ctx) => {
    var w = width();
    var h = height();
    var uiScale = Math.min(h * 0.03, w*0.03);
    drawStars(ctx,-Date.now()*0.03,0,3,0);

    // Progress meter
    ctx.lineWidth = uiScale * 0.2;

    // bg line
    ctx.strokeStyle='#555';
    ctx.beginPath();
    ctx.moveTo(w/2 - w*14/36, h/2);
    ctx.lineTo(w/2 + w*14/36, h/2);
    ctx.stroke();

    for (let i = 0; i < planets.length + 1; i++) {
      var x = (i - 7) * w / 18 + w/2;
      if (i <= currLevel) {
        ctx.beginPath();
        ctx.arc(x, h*0.5,uiScale*0.6,0,6.29);
        ctx.fillStyle='#fff';
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(x, h*0.5,uiScale*0.5,0,6.29);
        ctx.fillStyle='#000';
        ctx.strokeStyle='#f55';
        ctx.fill();
        ctx.stroke();
      }
    }
  };
}

function Win() {
  add(new Text('Planet Korva-6', ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));
  add(new Text('Package Delivered!', ()=>width()/2, ()=>height()/2, '#5f5', 0.6, 'center'));
  add(new StartButton('Main Menu'));
  bus.on('start', () => { transition(0); });

  this.render = (ctx) => {
    drawCharPlayer(ctx);
    drawCharZoren(ctx, '#f55');
    drawDialogBox(ctx,
      'Professor Quinn',
      'Is that a Xenotransponder?? My brother Zorn must have sent this. Thank you, Courier!'
    );
  };
}

// Init/Reset game
function init() { bus.emit('scene', 2); }

// Go to scene number
function transition(s) {
  bus.emit('txn');
  // When transition animation done, swap scene and perform fade in
  bus.on('txn-done', () => {
    bus.emit('scene', s);
    add(new transition$1(0.9, false));
  });
  // Start transition animation and stop all updaters
  get().forEach((go) => {go.update=undefined;});
  add(new transition$1(0.4, true));
}

(() => {
  // Scene configuration
  var scene = 0;
  var sceneConfig = (sceneNum) => {
    scene = sceneNum;
    bus.clear();
    bus.on('scene', sceneConfig);
    audio.stopMusic();
    audio.setup();
    clear();

    // [SCENE = 0] MAIN MENU
    if (scene == 0) { add(new MainMenu()); }

    // [SCENE = 1] INSTRUCTION
    if (scene == 1) { add(new Intro()); audio.music(); }

    // [SCENE = 2] GAME
    if (scene == 2) { add(new Engine()); audio.bgRocket(); }

    // [SCENE = 4] LOSE SCREEN
    if (scene == 4) { add(new GameOver()); }

    // [SCENE = 5] WIN SCREEN
    if (scene == 5) { add(new Win()); }
  };

  bus.on('scene', sceneConfig);
})();

isMobile = ()=>/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

window.addEventListener('touchstart', (evt) => {
  evt.stopPropagation();
  bus.emit('tap', { x: evt.touches[0].clientX, y: evt.touches[0].clientY });
});

window.addEventListener('mousedown', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (!isMobile()) { bus.emit('tap', { x: evt.x, y: evt.y });}
});

window.addEventListener('mousemove', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (isMobile()) {
    bus.emit('move', { x: -1, y: -1 });
  } else {
    bus.emit('move', { x: evt.x, y: evt.y });
  }
});

init();

// Wrap in closure to allow variable minification.
(() => {
  // Game loop
  var lastTime = Date.now();
  var removeQueue = [];
  var noop = () => {};

  var gameloop = () => {
    // Compute frame time in seconds
    var currTime = Date.now();
    var dT = (currTime - lastTime) * 0.001;
    if (dT > 0.3) { dT = 0.3; }

    // Clear frame
    ctx.fillStyle = '#225';
    ctx.fillRect(0, 0, width(), height());

    // Update, render, and queue game object removal
    removeQueue.length = 0;
    get().forEach((g) => {
      (g.ecs || []).forEach((u) => u(dT));
      (g.update || noop)(dT);
      (g.render || noop)(ctx);
      if (g.destroyed) { removeQueue.push(g); }
    });

    // Remove objects enqueued from before
    removeQueue.forEach((x) => remove(x));

    // Request next frame
    lastTime = currTime;
    requestAnimationFrame(gameloop);
  };
  gameloop();
})();
</script></html>