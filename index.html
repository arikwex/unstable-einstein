<html><title>UNSTABLE EINSTEIN</title><link rel="shortcut icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAMaGlDQ1BJQ0MgUHJvZmlsZQAASImVVwdUU8kanluSkJCEEoiAlNCbIL1KCaEFEJAq2AhJIKHEkBBU7GVRwbWLCFZ0VcS2ugKyFsReFsHeFwsqyrqoi6KovAkJ6LqvnPefM3e+fPPP3+5M7gwAWr08qTQP1QYgX1IoS4gIYY1NS2eROgAZkIAu8AR0Hl8uZcfHxwAog/3f5d0NgCj7q05KW/8c/6+iKxDK+QAg4yHOFMj5+RA3AYCv50tlhQAQlbzllEKpEs+BWE8GA4R4tRJnq/BOJc5U4SMDOkkJHIhbAdCg8niybADo9yDPKuJnQzv0TxC7SARiCQBaIyAO5It4AoiVsY/Iz5+sxBUQ20F9KcQwHuCT+Y3N7L/Zzxyyz+NlD2FVXgOiESqWS/N40/7P0vxvyc9TDPqwgY0qkkUmKPOHNbyVOzlaiakQd0kyY+OUtYa4VyxQ1R0AlCJSRCar9FFjvpwD6weYELsIeKHREBtDHC7Ji41R85lZ4nAuxHC1oFPFhdwkiA0gXiSUhyWqdTbLJieofaF1WTIOW82f48kG/Cp9PVDkJrPV9t+IhFy1fYxeLEpKhZgCsVWROCUWYjrEzvLcxGi1zqhiESd2UEemSFDGbwVxglASEaKyjxVlycIT1Pql+fLBfLHNIjE3Vo0PFIqSIlX1wU7xeQPxw1ywVqGEnTxoRygfGzOYi0AYGqbKHXsulCQnqu30SgtDElRzcYo0L16tj1sI8yKUvAXEHvKiRPVcPKUQLk6VfTxLWhifpIoTL87hRcWr4sGXgxjAAaGABRSwZYLJIAeIW7rqu+Av1Ug44AEZyAZC4KRmBmekDoxI4DMRFIM/IBIC+dC8kIFRISiC/OchVvV0AlkDo0UDM3LBU4jzQTTIg78VA7MkQ95SwBPIiP/hnQcbH8abB5ty/N/zg+xXhg2ZGDWjGPTI0hrUJIYRQ4mRxHCiPW6EB+L+eAx8BsPmhvvgvoN5fNUnPCW0ER4RrhPaCbcniefJvotyNGiH9sPVtcj8tha4DbTpiYfgAdA6tIwzcSPghHtAP2w8CHr2hCxHHbeyKqzvbP8tg2/ehlqP7EJGycPIwWS772fSHeieQ1aUtf62PqpYM4fqzRka+d4/55vqC2Af/b0mtgg7iJ3FTmDnsSNYPWBhx7EG7BJ2VImHVteTgdU16C1hIJ5caEf8D388tU9lJeUutS6dLp9UY4XCqYXKjceZLJ0mE2eLClls+HUQsrgSvvMIlpuLmysAym+N6u/rLXPgG4IwL3zlCpoA8C2FZPZXjmcJwOGnADDefeUs38BtsxyAo618haxIxeHKBwH+S2jBnWYITIElsIP5uAEv4A+CQRiIAnEgCaSBibDKIrjOZWAKmAHmghJQBpaDNaASbAJbwU6wBxwA9eAIOAHOgIugFVwHd+Hq6QAvQTd4B/oQBCEhNISBGCJmiDXiiLghPkggEobEIAlIGpKBZCMSRIHMQOYjZchKpBLZgtQgPyOHkRPIeaQNuY08RDqRN8hHFEOpqB5qgtqgI1EflI1Go0noBDQbLUCL0QXoUrQCrUZ3o3XoCfQieh1tR1+iPRjANDEmZo45YT4YB4vD0rEsTIbNwkqxcqwa24s1wvd8FWvHurAPOBFn4CzcCa7gSDwZ5+MF+Cx8CV6J78Tr8FP4Vfwh3o1/IdAIxgRHgh+BSxhLyCZMIZQQygnbCYcIp+Fe6iC8IxKJTKIt0RvuxTRiDnE6cQlxA3EfsYnYRnxM7CGRSIYkR1IAKY7EIxWSSkjrSLtJx0lXSB2kXg1NDTMNN41wjXQNicY8jXKNXRrHNK5oPNPoI2uTrcl+5DiygDyNvIy8jdxIvkzuIPdRdCi2lABKEiWHMpdSQdlLOU25R3mrqalpoemrOUZTrDlHs0Jzv+Y5zYeaH6i6VAcqhzqeqqAupe6gNlFvU9/SaDQbWjAtnVZIW0qroZ2kPaD10hl0ZzqXLqDPplfR6+hX6K+0yFrWWmytiVrFWuVaB7Uua3Vpk7VttDnaPO1Z2lXah7VvavfoMHRcdeJ08nWW6OzSOa/zXJeka6MbpivQXaC7Vfek7mMGxrBkcBh8xnzGNsZpRoceUc9Wj6uXo1emt0evRa9bX1ffQz9Ff6p+lf5R/XYmxrRhcpl5zGXMA8wbzI/DTIaxhwmHLR62d9iVYe8NhhsEGwgNSg32GVw3+GjIMgwzzDVcYVhveN8IN3IwGmM0xWij0WmjruF6w/2H84eXDj8w/I4xauxgnGA83Xir8SXjHhNTkwgTqck6k5MmXaZM02DTHNPVpsdMO80YZoFmYrPVZsfNXrD0WWxWHquCdYrVbW5sHmmuMN9i3mLeZ2FrkWwxz2KfxX1LiqWPZZblastmy24rM6vRVjOsaq3uWJOtfaxF1mutz1q/t7G1SbVZaFNv89zWwJZrW2xba3vPjmYXZFdgV213zZ5o72Ofa7/BvtUBdfB0EDlUOVx2RB29HMWOGxzbRhBG+I6QjKgecdOJ6sR2KnKqdXrozHSOcZ7nXO/8aqTVyPSRK0aeHfnFxdMlz2Wby11XXdco13muja5v3Bzc+G5Vbtfcae7h7rPdG9xfezh6CD02etzyZHiO9lzo2ez52cvbS+a116vT28o7w3u9900fPZ94nyU+53wJviG+s32P+H7w8/Ir9Dvg96e/k3+u/y7/56NsRwlHbRv1OMAigBewJaA9kBWYEbg5sD3IPIgXVB30KNgyWBC8PfgZ256dw97NfhXiEiILORTynuPHmclpCsVCI0JLQ1vCdMOSwyrDHoRbhGeH14Z3R3hGTI9oiiRERkeuiLzJNeHyuTXc7ijvqJlRp6Kp0YnRldGPYhxiZDGNo9HRUaNXjb4Xax0ria2PA3HcuFVx9+Nt4wvifx1DHBM/pmrM0wTXhBkJZxMZiZMSdyW+SwpJWpZ0N9kuWZHcnKKVMj6lJuV9amjqytT2sSPHzhx7Mc0oTZzWkE5KT0nfnt4zLmzcmnEd4z3Hl4y/McF2wtQJ5ycaTcybeHSS1iTepIMZhIzUjF0Zn3hxvGpeTyY3c31mN5/DX8t/KQgWrBZ0CgOEK4XPsgKyVmY9zw7IXpXdKQoSlYu6xBxxpfh1TmTOppz3uXG5O3L781Lz9uVr5GfkH5boSnIlpyabTp46uU3qKC2Rthf4Fawp6JZFy7bLEfkEeUOhHjzUX1LYKX5QPCwKLKoq6p2SMuXgVJ2pkqmXpjlMWzztWXF48U/T8en86c0zzGfMnfFwJnvmllnIrMxZzbMtZy+Y3TEnYs7OuZS5uXN/m+cyb+W8v+anzm9cYLJgzoLHP0T8UFtCL5GV3Fzov3DTInyReFHLYvfF6xZ/KRWUXihzKSsv+7SEv+TCj64/VvzYvzRracsyr2UblxOXS5bfWBG0YudKnZXFKx+vGr2qbjVrdenqv9ZMWnO+3KN801rKWsXa9oqYioZ1VuuWr/tUKaq8XhVStW+98frF699vEGy4sjF4495NJpvKNn3cLN58a0vElrpqm+ryrcStRVufbkvZdvYnn59qthttL9v+eYdkR/vOhJ2narxranYZ71pWi9Yqajt3j9/duid0T8Nep71b9jH3le0H+xX7X/yc8fONA9EHmg/6HNz7i/Uv6w8xDpXWIXXT6rrrRfXtDWkNbYejDjc3+jce+tX51x1HzI9UHdU/uuwY5diCY/3Hi4/3NEmbuk5kn3jcPKn57smxJ6+dGnOq5XT06XNnws+cPMs+e/xcwLkj5/3OH77gc6H+otfFukuelw795vnboRavlrrL3pcbWn1bG9tGtR27EnTlxNXQq2euca9dvB57ve1G8o1bN8ffbL8luPX8dt7t13eK7vTdnXOPcK/0vvb98gfGD6p/t/99X7tX+9GHoQ8vPUp8dPcx//HLJ/InnzoWPKU9LX9m9qzmudvzI53hna0vxr3oeCl92ddV8ofOH+tf2b365c/gPy91j+3ueC173f9myVvDtzv+8viruSe+58G7/Hd970t7DXt3fvD5cPZj6sdnfVM+kT5VfLb/3Pgl+su9/vz+filPxhs4CmCwoVlZALzZAQAtDZ4d4L2NMk51FxwQRHV/HUDgP2HVfXFAvADYEQxA8hwAYuAZZSNs1hBTYa88wicFA9TdfaipRZ7l7qayRYU3IUJvf/9bEwBIjQB8lvX3923o7/+8DQZ7G4CmAtUdVClEeGfY7KxErR2vwPeiup9+k+P3PVBG4AG+7/8FIq+PWw5pimMAAACEZVhJZk1NACoAAAAIAAYBBgADAAAAAQACAAABEgADAAAAAQABAAABGgAFAAAAAQAAAFYBGwAFAAAAAQAAAF4BKAADAAAAAQACAACHaQAEAAAAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQACoAIABAAAAAEAAABAoAMABAAAAAEAAABAAAAAANVxA6IAAAAJcEhZcwAACxMAAAsTAQCanBgAAAK2aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA2LjAuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MjgwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI4MDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMQCMMAAAOmElEQVR4Ae1beWxVZRb/3dfXndKWltJCkZYdBGRVFoGCRB3QxCGYyKKJonGiYUTCaDITk8mQUSHRqH8MKnEBRyEmlEw0A4kCA7IPINu0FKS2QAu0LAVK9/funN9573u8Pt5S4GFBPMl9997vfsvZz/nOvc/q2bOnjXYG27ZhWVa7YOFol1W9i5Lw2NhYdOzYEW63G+3BiKgygETwaAsY4o8cOYL9+/ejS5cucDqdaG5u/kW1IWoMIOGdOnVCamqqSpKEuFwuj1RxrXrHxMSguroaU6dOxcSJE7Fz506kp6cjIyMD9fX1IZlAxnEsD17fLESNAURo7969SlTXrl2Rl5eHzp07q4o3NTepZMkk2joRT0xMxIULF/Dwww/jyy+/xPxX52PXrl04e/YsxC+hqalJtSnQN/CeY2k60YCbZgARoqTJgCeeeAKVlZXYunUrfvjhB+zevVvtmwTl5uYiOTkZLS0taGxs9OHeoUMHdOvWDW/+/U2sXr0aJ06cwJYtW9CrVy8ltKGhoZU2JCQk4MCBAygqKgLHcr5AJvkmb8OFsw19wnYh8bRfSu/999/Hu+++i0OHDqldf//999i0aZNvfH5+Prp3795KdUkEgVKdPn06Dh8+jHfeeQfLli3DiBEjlMiKigo90zRKS0uxdOlSXL58Ga+99hrGjh2L48ePIz4+vtW8vkUjXFg3EwbJearqPffco1J/77338Morr+iSlAxV/OTJkyguLlYb/+CDD3zokGAStHbtWjz66KNqIkatr1y5gsI1hXjm6We0/4MPPqimQeY89NBD+Oabb1TTevfujXvvvVc1oLa2Fg7H9Sv0TTGA2NGu4+Li1AyOHTumiOXk5PgINRdUe9r3zz//rCpMM/nqq6/w3XffYcqUKTqeBNA/GEIOHjyI119/XZk0ZswYbN++3ccwat7SfyzFvD/Ow/jx41FeXq5RxKzX1nNEBhhk/O2M1+bgcyJDx7dx48ZrCCIi/mMNYpR+WVmZev7s7Gwl3PQjU826ly5dwooVKzBv3jw899xz+Oijj9TfsC9Vn060pKREzYUMNtHB4BcpUkRkAFWZqkmkKEUe586dM3Rcc37yySdVsozpBvyRMESaZzzzeWC7GWPaN2zYoFFl8ODB6vjM/CtXrsSsWbMwcuRINTkKg/6AjKADDTa3/9ohGWBUm4mKP9De6aEZr3kw1DH2p6elIy09DclJyRg/Ybx6/HCLGwI5tyHSfx1zHTiHuSehJJJSf/bZZ/Htt9/igQceQF1dnR40R8LAgQNBn8K+weCqmPyeUv0YbhhqPv/8c9x3332qkgxjdF48yGVqhnFcfsP10iAa2G7uwxFt+vBs+lEgvDb3JIhMyMzMxMsvv6wMqBOzot8g0Hf07dsXc+fORb9+/bQv5wiEoG6TExvCioqLwPA1ZMgQlTxtnRlbUlKSrw+J5eQcxyMS8YFItOWeQjHEB/YvKCjA888/j4OSHzz11FPqh95++23Fm33pY/xzD//xQTWAC50/f14dy5LFS7Bi+Qp1cP3791fiSKxD+ghGOpe/ZPwnv9XXRguorS+++KKm1I899hjS0tJ0aUYYAkN1KAiqAexMFWdWN27cOFypu4I5c+Zgx44dKgUubHklEkoqoRaMdruxbTpB4miIpwAZahmimSOYfoHrB2UAiWKYoqoTMjMysWfPHnz22WfqUNgWzJ7Y3h5AkyPwzKhFOH36NDZv3qz+K1yS1IoBJJw2zJ1cjx49VNrkYnZOttoVU1TaPsHEab1p5x/ibZhgwqOJXtSAcPuFVj6AjoKhjV5+27ZtStby5csxbdo0bW9nOsMuH2iK3JkSSBOFZRgUOIkygOpMTjGkcFNDWLRokdpUnmxrDbAfFwpczDxv7zOJJG41NTWqsTThcOpPfJ0cRC/KjQZh5syZWLhwIYYPH673/DGE305q70PO78Iw4MyZM+qwhw0bptlhOLydjPfcsXEryp0cNxZGwkZtwk3gt/5tc2nCXjjVN8iqE6SacGvJ4mRVVRUa6hv0+e2s7oaAYOdAAQbrY9oc9PhMcJYsWQKqDLOmhX9aiE8//RQ//vijL9zdfPXNLPnLnQ0jwq0oCZ2luybuslh44EansLBQc2juwHzq74214Sa7E59pFCCRLDGxgsMwyGjATHDGjBlKk3EudyKBkXD2JUKa3oo20A+wRP3CCy9osZITGGcYabI78bmPAQx1LFBevHhR6XjkkUe0xETifWZwJ1IYAWcfA5gCM3FgyZnlpwEDBujQG5X+jY6LgG/UHysDiCyTIW6ACNxSMudXIjw73qgvfLtMqAyg+nMbybA3beo0DB06VPGjVjgsn5JcF85tCUHXNeEt6qzUMRs028inn3kaWVlZuhx3VtQK5gq/VnBQ+qz1cfc0atQoDBo0SPfS69at0xI0tYG1AMKdYtfXIywnPTyrpoz93BG+8cYbWLNmTas5yJzRo0f79gitHkb5RjNOb9opUfm6wGSrvrNtiqCcyLS2nlJNwEQAFhFIPAugLDHzvRth/Yb1Pgd5q7TALfjxIKoknIe2GRoUk2t/mKCKEot2esayB+cgxMSlyANOIA99rXxyFZQBdFj0AXSENAFqBOuBfFNLZhSuLtR7Dos2AwwBDsGahz9om2BIRrBfICjDOE76kGE8E2IcnrJYc2054lK6Sv2S3xJIGzsFgK8iRCZQE0wBwZSSmBIT+I6A+4RogkpNcCJejeJnK87ZqL5ko0Gu4wSzzBQL3TIsJHlQUEYYJlHqhuCaWhsVF4Dzl21J3oDKqiwMm/43NJV8jYr/7UTuwBFA8xW45bBi4lpx08cAQ5jJ+ihpMsXU01kpevzxx1tlhWQY+5gxZo62nA3x7Hv4pI2Nh904Im/caoV4SpaEJjpt9JIK98R+FobmO7TNaAKJbxKh7ihxY0upjZOX5V6Y4nK3ICU+B1Nn/xkXqmYje+sq7P7nX5DV3xPa3S38+oRke1QqRrK/vxKJYGBMgwTycxZujlgvZOQgsJ19eM/zdQElLwO2FLuxbKeNqitAiggnTaSdKkeKfAASK0RWSvu2crl2AX1yPGtwqXop9X+93YXCYo9AOYZj0+MtxDnkWyU40CGtE7J7j0Zydh6K/v0xUrJ7CHdpHjKZ1yd4rSY06pQyawQMhWVlZdqRxPJg4sR3c2QE+7UV1Hal88FyNz7ZbSNNCO8ixWZKvVl42yRT8UxCMxPlmRwrD9jKLLaR/2v3ubGuFOiZCnQUwjknxzXK4bKlSux2oUkKO1LywsAJczBy9iKcKtoDZ1JGKxOIyAASZaTLr7nM/b59+7Ru+MUXX6hj5G7SaIZ2CvFDFSahlOC/9tvIEORj5b1lgwiGRPgD7xulnf1zkqX/IRuX622cOGuL5N3oK+bRTKKlT8BQwVlMJiYWzY0NiI2PQ79xM5HZIxd1VTsQkyDvO7whMiIDSLzJBPntDuHo0aNaPerTpw8WLFiAVatWaTs1IVKUMESWVLjVbhPFHI20dZKAH0rcJdQ55Uwm7S21UVQhDSLlGGkLN5ZTWZa8RG22kdq5B3pNeAnnzwhD6Qi9cI0TNA/8zwyR3CrzU5f169fjww8/1Mf8EoSbJr6fp5lMmjRJtcU4UP85zDUJIpSflXAl15Sct0nbQ/2wX5Jgu18cZouYQJaYBVWe2hEOLOngFrt3xsUivdsAXcvVXKfRwHY3o00MoGrzQygWTPk5C4EltJ9++kkzSGrC5MmT9dU084hQDPAntlY+FIuEfCBhMaKvp8Tbk4oEwZyaERnIZTpped+ZlAbK3u1lgOiPuMo2AoniwToB37ezhMaIwDIatYPqX1BQoCV2XgfzB/7CcnpXbhMNXhzpP5IkOpB4mpL/fOHJIBNkTIt8eygdLQfl7lm5zQwwCzAvYN3d2DsTJmoGP2njpzPz58/XqlIoJhgfkNXRI8G2E+GJ832zLOR3Ai6KBjnFeZIp4UC1UQUiOcb5k5BhkiJ3gO3iDldymHCDQz0zUYHPuQA1gS9XuGHix45vvfWWVpoNk/znMQT3lZhOLeB9BBr0Of0FneDIfAuDulqobrQl3kcay5emUtOQCNVQW4PK4s2QYHI1NZbrG2KAP0G8prpzS829w5ixY7B48WLfO8ZAUxBhqNSY4k7IszTRSfZ+9Uppkhm+w3tP53dWilVDugC9si30EQYMlvHVdZ7kiVrlP9aDH3MB+YqUUhZNqTyyHYfXL0e6ZIQtDRc1TLJfVBjAiUgo9w0XazxFVfN6is9Cwe+GijQ7A8dqxEEJkone7I8hj1kgbT1R2k+I48sW0c0Y5UE3JdHC7PsdkOiGKmFCB/Fs8dKXY3jEWDZcYu/8iCM+KQ7VZcXYtfJVdMqRh5IfuF188+XRRc+MoTC8gXZjHuY9fbAp6JEpteQEC3MnODA5X8KiEFkhR60kSA0S3ng+JWlw6SVgeDbw0iQHMjoypHlm7C0mtKDAgS7CmKPCQGpDnZh1nXClwRWDhOQEkbwTJ4r/i02f/AENVSVI6DQCLfXVIn06QQ9cvTItUToHqn7gtAyBZELHJAuzxsVgZJ6NgxLjT9TYSgil31Uc5aBcCwNyHbo7pJobEyITewkT5k1x4NBxSY5O2TgjDJQiPiyRcOmRElQU/QcHVr0KSzQrOXeEbAhPiwLQ3mQiL9wyBpgFwp0NExjfB3QXQuVgitzSwv8EiPrHcc/hmYHEm2ueeU+gOYyR3eL9fUT6DWKGCcKQA6UY8fth6Jcp5pCahoTUPDTXn/US7xlnftuVAUSCTFBi5ExaE5mpCOH+4E+8aTfMMM/IxBTP1ztIiPXYSUrPsWg6dwGuRjo94WgQiLoPCLJGxCYSQ5JJTODBwYbYYBOpNnCsHMY/cDdIsF2NkvyIIwnj69tdAxRT7084Qv37BV4bffFahde/sxdblLWBQ3z3t4UG+LCJ+oVhTeiJf+UMCE24efIbAwwn7tbzbxpwt0re0P2bBhhO3K3nu14D/g+r4U14Nbq3NwAAAABJRU5ErkJggg==" sizes="64x64"/><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><style>canvas{width:100%;height:100%;}body{margin:0;background:#000;}</style><canvas><script>const canvas = document.getElementsByTagName('canvas')[0];
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.lineCap='round';
ctx.lineJoin='round';

var w, h;
function width() { return w; }
function height() { return h; }

function resize() {
  canvas.width = window.innerWidth * 1;
  canvas.height = window.innerHeight * 1;
  w = canvas.width;
  h = canvas.height;
}resize();
window.addEventListener('resize', resize);

// list of all active game objects
var g = [];

function get() { return g }
function add(obj) { g.push(obj); }
function remove(obj) { g = g.filter((x) => x != obj); }
function clear(obj) { g = []; }

function e() {
  var HANDLES = {};

  return {
    clear: () => HANDLES = {},
    on: (e, handler) => (HANDLES[e] || (HANDLES[e] = [])).push(handler),
    off: (e, handler) => (HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler)),
    emit: (e, data) => (HANDLES[e] || []).forEach((handler) => handler(data)),
  };
}

// Create global event bus from event emitter
b = new e();
var bus = b;

function pulse(fn, min, max, period) {
  var anim = 0;
  return (dT) => {
    anim += dT;
    fn((Math.sin(anim / period * 6.3) + 1) / 2 * (max - min) + min);
  }
}
function transition$1(duration, fadeOut) {
  var anim = 0;
  this.update = (dT) => {
    anim += dT / duration;
    if (anim > 1 && fadeOut) {
      this.destroyed = true;
      bus.emit('txn-done');
    }
  };
  this.render = (ctx) => {
    var w = width();
    var h = height();
    var tf = 0;
    if (fadeOut) { tf = Math.max(1-anim*anim, 0); }
    else { tf = Math.pow(Math.max(anim-0.3, 0)*1.3, 2);}
    // Top plate
    ctx.save();
    ctx.fillStyle = '#343';
    ctx.translate(0, -h*0.6 * tf);
    ctx.fillRect(0, 0, w, h/2);
    ctx.strokeStyle = '#7f7';
    ctx.fillStyle = '#7f7';
    ctx.lineWidth = w * 0.03;
    ctx.fillRect(0,h/2,w,h*0.05);
    ctx.strokeRect(w*0.25, h*0.2, w*0.5, h*0.2);
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font=`${w*0.05}px monospace`;
    ctx.fillText('UNSTABLE',w*0.5,h*0.27);
    ctx.fillText('EINSTEIN',w*0.5,h*0.33);
    ctx.restore();

    // Bottom plate
    ctx.save();
    ctx.fillStyle = '#343';
    ctx.translate(0, h*0.6 * tf);
    ctx.fillRect(0, h/2, w, h/2);
    ctx.fillStyle = '#7f7';
    ctx.fillRect(0,h*0.55,w,-h*0.05);
    ctx.restore();
  };
}

function StartButton(txt = 'Begin') {

  var fn = ({x, y}) => {
    var w = width();
    var uiScale = w * 0.1;
    if (x > w*0.97 - uiScale*2 && x < w*0.97 && y > 0 && y < w*0.02+uiScale*0.8) {
      bus.emit('start');
      bus.off('tap', fn);
    }
  };

  bus.on('tap', fn);

  this.render = (ctx) => {
    var w = width();
    var uiScale = w * 0.1;

    ctx.save();
    ctx.translate(w * 0.97-uiScale,w*0.02+uiScale*0.4);
    var p = (Date.now() % 500) / 500;
    var s = (1-(1-p)*(1-p)) * 0.4 + 0.8;
    ctx.scale(s,s*1.1);
    ctx.strokeStyle = '#0a0';
    ctx.lineWidth = uiScale * 0.1 * (1 - p);
    ctx.strokeRect(-uiScale, -uiScale*0.4, uiScale*2, uiScale*0.8);
    ctx.restore();

    ctx.fillStyle = '#0a0';
    ctx.fillRect(w * 0.97, w*0.02, -uiScale*2, uiScale*0.8);

    ctx.fillStyle = '#fff';
    ctx.font = `${uiScale*0.35}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(txt, w*0.97 - uiScale * 1, w*0.02+uiScale * 0.4);
  };
}

function Audio() {
  var audioCtx = null;
  var sampleRate = null;

  // Sounds to be loaded on init (cursed AudioContext waiting for interaction)
  var gateCloseSound;
  var gateOpenSound;
  var collisionSound;
  var musicBuffer;
  var rocketBuffer;

  var sin = (i) => Math.min(Math.max(Math.sin(i), -1), 1);
  var saw = (i) => ((i % 6.28)-3.14)/6.28;
  var sqr = (i) => Math.min(Math.max(Math.sin(i) * 1000, -1), 1);
  var win = (i, ts, te) => {
    if (i<ts*44100 || i>te*44100) {return 0;}
    return 1 - ((i/44100) - ts)/(te - ts);
  };
  var note = (i, tone, time, dur) => 0.01*sqr(i / (80/Math.pow(2,tone/12))) * win(i,time,time+dur);
  var hhat = (i, time) => 0.02*Math.random() * win(i,time,time+0.06);

  var generate = (duration, fn, fading = true) => {
    var audioBuffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
    var buffer = audioBuffer.getChannelData(0);
    var N = audioBuffer.length;
    for (var i = 0; i < N; i++) {
      var p = i / N;
      var envelope = 1 - p;
      if (!fading) { envelope = 1; }
      buffer[i] = fn(i*44100/sampleRate) * envelope;
    }
    return audioBuffer;
  };

  this.init = () => {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate;

    // Transition animation - Gate whirring close
    gateCloseSound = generate(0.6, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0);
    });

    // Transition animation -  Gate whirring open + noise of steam
    gateOpenSound = generate(1, (i) => {
      return 0.05 * sqr(i/250) * (sin(i/300)+0) + 0.1 * Math.random() * win(i, 0, 1);
    });

    // Matter sound
    matterSound = generate(0.15, (i) => {
      return 0.04 * sin(i/(15 - i / 2000));
    });

    // Collision / take damage
    collisionSound = generate(0.8, (i) => {
      return 0.1 * Math.random() * win(i, 0, 0.8) * (sqr(i/200)+1);
    });

    // Space sound
    spaceSound = generate(0.7, (i) => {
      return 0.1 * (
        saw(i/30) * win(i, 0, 0.1) +
        saw(i/50) * win(i, 0.1, 0.2) +
        saw(i/40) * win(i, 0.2, 0.3) +
        saw(i/20) * win(i, 0.3, 0.4) +
        saw(i/10) * win(i, 0.4, 0.5)
      );
    });

    // Time sound
    timeSound = generate(0.4, (i) => {
      var acc = 0;
      for (let q = 0; q < 10; q++) {
        acc += sin(i/(10+q*q/20)) * win(i, q/10, (q+1)/10);
      }
      return 0.05*acc;
    });

    musicBuffer = generate(0.2*48, (i) => {
      var d = 0.2;
      var acc = 0;
      for (let q = 0; q < 48; q+=8) {
        acc += hhat(i, d*(q+0))+
          hhat(i, d*(q+1))+
          hhat(i, d*(q+2))*3+
          hhat(i, d*(q+3))+
          hhat(i, d*(q+4))+
          hhat(i, d*(q+6))*3;
      }
      // Phrase 1
      acc += note(i, 12, d * 8, d * 1) +
        note(i, 7, d * 11, d * 1) +
        note(i, 10, d * 14, d * 1.5) +
        note(i, 9, d * 16, d * 1.5) +
        note(i, 3, d * 18, d * 1.5) +
        // Phrase 2
        note(i, 6, d * 32, d * 1) +
        note(i, 3, d * 35, d * 1) +
        note(i, 5, d * 38, d * 1.5) +
        note(i, 3, d * 40, d * 1.5) +
        note(i, 0, d * 42, d * 1.5);
      return acc;
    }, false);

    rocketBuffer = generate(3, (i) => {
      return 0.01 * (saw(i/300)*sqr(i/130) + 1);
    }, false);
  };

  var play = (audioBuffer) => {
    var source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    source.start();
  };

  this.setup = () => {
    if (audioCtx == null) { this.init(); }
    bus.on('txn', () => { play(gateCloseSound); });
    bus.on('txn-done', () => { play(gateOpenSound); });
    bus.on('hit', () => { play(collisionSound); });
    bus.on('space-change', () => { play(spaceSound); });
    bus.on('matter-change', () => { play(matterSound); });
    bus.on('time-change', () => { play(timeSound); });
  };

  var musicSource = null;
  this.music = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = musicBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.bgRocket = () => {
    if (audioCtx == null) { this.init(); }
    musicSource = audioCtx.createBufferSource();
    musicSource.buffer = rocketBuffer;
    musicSource.loop = true;
    musicSource.connect(audioCtx.destination);
    musicSource.start();
  };
  this.stopMusic = () => {
    try {
      if (musicSource != null) { musicSource.stop(); }
    } catch (e) {}
  };
}

var audio = new Audio();

function Text(str, x, y, color = '#fff', size='1', align='left') {
  this.str = str;
  this.x = x;
  this.y = y;
  this.color = color;
  this.size = size;

  this.render = (ctx) => {
    var uiScale = width() * 0.08;
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = this.color;
    ctx.font = `${this.size * uiScale}px monospace`;
    ctx.fillText(this.str, this.x(), this.y());
  };
}

function MainMenu() {
  // Title card
  add(new Text('UNSTABLE EINSTEIN', ()=>width()/2, ()=>height()*0.2, '#77f', 1, 'center'));

  // Push to star pulser
  var pushToStart = new Text('[ Press to start ]', ()=>width()/2, ()=>height()*0.35, '#77f', 0.5, 'center');
  pushToStart.ecs = [pulse((x) => {pushToStart.size = x;}, 0.45, 0.55, 1)];
  add(pushToStart);

  // By me :)
  add(new Text('by Ariel Wexler', ()=>width()/2, ()=>height()*0.5, '#fff', 0.35, 'center'));

  // Touch anywhere to go to intro
  var fn = () => {
    transition(1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);

  this.render = (ctx) => {
    const w = width();
    const h = height();
    const x = w * 0.3;
    const y = h * 1.02;
    ctx.save();
    let a = Date.now() * 0.006;
    var s = h * 0.2;
    ctx.translate(x, y);
    let breath = Math.cos(a * 0.7);
    let th = -s * (1.95 + breath * 0.05);
    let tw = s * (0.5 + (1 - breath) * 0.02);
    // Body
    ctx.fillStyle = '#fff';
    ctx.fillRect(-tw, 0, 2*tw, th);
    // Hair
    ctx.beginPath();
    ctx.moveTo(s*0.5, th + 2);
    for (let i = 0; i < 10; i++) {
      let p = i / 10;
      let dx2 = Math.cos(p * 5) * (tw + s * 0.25) - s * 0.25;
      let dx = Math.cos(p * 5 + Math.cos(a+i) * 0.1) * s * 0.2 + dx2;
      let dy2 = Math.sin(p * 4.8) * s * 0.5 - s * 0.4 * p;
      let dy = Math.sin(p * 4.8) * s * 0.2 + dy2;
      ctx.lineTo(dx, th + 2 - dy);
      ctx.lineTo(dx2, th + 2 - dy2);
    }
    ctx.lineTo(-tw, th + s * 0.3);
    ctx.closePath();
    ctx.fill();
    // Glasses
    ctx.beginPath();
    ctx.fillStyle = '#7af';
    ctx.arc(tw-s*0.05,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(tw-s*0.55,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.restore();
  };
}

var persist = (() => {
  var dist = 0;

  var a = {
    setDist: (a) => {dist = a;},
    getDist: (a) => {return dist;}
  };

  return a;
})();

function Intro() {
  add(new Text('Instructions', ()=>width()*0.03, ()=>width()*0.05, '#fff', 0.5, 'left'));
  add(new StartButton());
  bus.on('start', () => {
    transition(2);
  });

  this.render = (ctx) => {
    const w = width();
    const h = height() * 0.8;

    const BW = w / 40;
    const BH = h / 10;
    ctx.save();

    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = this.color;
    ctx.font = `${w * 0.03}px monospace`;

    // RED OBSTACLES
    ctx.fillStyle = '#f00';
    ctx.fillRect(w/4 - BW/2-BH/3, h/3 - BH, BW, BH);
    ctx.fillRect(w/4 - BW/2+BH/3, h/3, BW, BH);
    ctx.fillStyle = '#fff';
    ctx.fillText('Avoid red obstacles by', w*3/8, h/3-BH/3.5);
    ctx.fillText('destabilizing gravity.', w*3/8, h/3+BH/3.5);

    // GREEN OBSTACLES
    ctx.fillStyle = '#0e0';
    ctx.fillRect(w/4 - BW/2-BH/3, h*2/3 - BH / 10, BW, BH/5);
    ctx.fillRect(w/4 - BW/2+BH/3, h*2/3- BH, BW, BH*2);
    ctx.fillStyle = '#fff';
    ctx.fillText('Avoid green obstacles by', w*3/8, h*2/3-BH/3.5);
    ctx.fillText('destabilizing space.', w*3/8, h*2/3+BH/3.5);

    // BLUE OBSTACLES
    ctx.fillStyle = '#00f';
    ctx.fillRect(w/4 - BW/2-BH/3, h - BH, BW, BH/5);
    ctx.fillRect(w/4 - BW/2-BH/3, h + BH, BW, -BH/5);
    ctx.fillRect(w/4 - BW/2+BH/3, h - BH, BW, BH*0.95);
    ctx.fillRect(w/4 - BW/2+BH/3, h + BH, BW, -BH*0.95);

    ctx.fillStyle = '#fff';
    ctx.fillText('Avoid blue obstacles by', w*3/8, h-BH/3.5);
    ctx.fillText('destabilizing time.', w*3/8, h+BH/3.5);

    ctx.restore();
  };
}

function Player(engine) {
  let x = width() * 0.2;
  let y = height() * 0.75;
  let vy = 0;
  let normalizedY = 0;

  this.getX = () => { return x; };
  this.getY = () => { return y; };

  this.update = (dT) => {
    x = engine.getScale() * 80;

    // Gravitation behavior
    const tl = engine.topLimit();
    const bl = engine.bottomLimit();

    const g = engine.getGravity();
    vy -= g * dT * 6;
    normalizedY += vy * dT;

    if (normalizedY < 0) { normalizedY = 0; vy = 0; }
    if (normalizedY > 1) { normalizedY = 1; vy = 0; }

    y = tl * normalizedY + bl * (1 - normalizedY);
  };
  this.render = (ctx) => {
    ctx.save();
    let a = Date.now() * 0.01;
    var s = engine.getScale() * 30;
    ctx.translate(x, y);
    if (normalizedY > 0.5) {
      ctx.scale(1, -1);
    }
    let breath = Math.cos(a * 0.7);
    let th = -s * (1.95 + breath * 0.05);
    let tw = s * (0.5 + (1 - breath) * 0.02);
    // Body
    ctx.fillStyle = '#fff';
    ctx.fillRect(-tw, 0, 2*tw, th);
    // Hair
    ctx.beginPath();
    ctx.moveTo(s*0.5, th + 2);
    for (let i = 0; i < 10; i++) {
      let p = i / 10;
      let dx2 = Math.cos(p * 5) * (tw + s * 0.25) - s * 0.25;
      let dx = Math.cos(p * 5 + Math.cos(a+i) * 0.5) * s * 0.2 + dx2;
      let dy2 = Math.sin(p * 4.8) * s * 0.5 - s * 0.4 * p;
      let dy = Math.sin(p * 4.8) * s * 0.2 + dy2;
      ctx.lineTo(dx, th + 2 - dy);
      ctx.lineTo(dx2, th + 2 - dy2);
    }
    ctx.lineTo(-tw, th + s * 0.3);
    ctx.closePath();
    ctx.fill();
    // Glasses
    ctx.beginPath();
    ctx.fillStyle = '#7af';
    ctx.arc(tw-s*0.05,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(tw-s*0.55,th+s * 0.8, s * 0.25, 0,6.29);
    ctx.fill();
    ctx.restore();
  };
}

function FixedWall(engine, tick, lane) {
  let x = engine.getTickX(tick);
  let y = engine.getLaneY(lane);

  const canHurtPlayer = () => {
    const py = engine.getPlayerY();
    const midY = engine.getLaneY(0.5);
    if (lane == 0 && py < midY) {
      return true;
    }
    if (lane == 1 && py > midY) {
      return true;
    }
    return false;
  };

  this.update = (dT) => {
    const s = engine.getScale() * 60;
    x = engine.getTickX(tick-0.1);
    y = engine.getLaneY(lane);
    if (x < -100) {
      this.destroyed = true;
    }
    const px = engine.getPlayerX();
    engine.getPlayerY();
    if (px > x - s/2 && px < x + s / 2) {
      if (canHurtPlayer()) {
        bus.emit('hit');
      }
    }
  };
  this.render = (ctx) => {
    ctx.save();
    const s = engine.getScale() * 60;
    const h = engine.laneHeight();
    ctx.translate(x, y);
    if (canHurtPlayer()) {
      ctx.fillStyle='#f00';
    } else {
      ctx.fillStyle='rgba(255,0,0,0.25)';
    }
    ctx.fillRect(-s/2, -h/2, s, h);
    ctx.restore();
  };
}

function StretchWall(engine, tick, mode) {
  let x = engine.getTickX(tick);
  let y = engine.getLaneY(0.5);
  let currSize = 0;

  const canHurtPlayer = () => {
    return currSize > 0.7;
  };

  this.update = (dT) => {
    const s = engine.getScale() * 60;
    x = engine.getTickX(tick+0.1);

    // Dynamic size
    let targetSize = mode;
    if (engine.getStretch()) {
      targetSize = 1 - mode;
    }
    currSize += (targetSize - currSize) * 6.0 * dT;

    if (x < -100) {
      this.destroyed = true;
    }
    const px = engine.getPlayerX();
    engine.getPlayerY();
    if (px > x - s/2 && px < x + s / 2) {
      if (canHurtPlayer()) {
        bus.emit('hit');
      }
    }
  };
  this.render = (ctx) => {
    ctx.save();
    const s = engine.getScale() * 60;
    const h = engine.laneHeight() * 2 * (0.9 * currSize + 0.1);
    ctx.translate(x, y);
    if (canHurtPlayer()) {
      ctx.fillStyle='#0e0';
    } else {
      ctx.fillStyle='rgba(0,255,0,0.25)';
    }
    ctx.fillRect(-s/2, -h/2, s, h);
    ctx.restore();
  };
}

function TimeWall(engine, tick, mode) {
  let x = engine.getTickX(tick);
  let currSize = 0;
  let anim = mode * 10;

  const canHurtPlayer = () => {
    return currSize > 0.2;
  };

  this.update = (dT) => {
    const s = engine.getScale() * 60;
    x = engine.getTickX(tick);

    // Dynamic size
    if (engine.getTime()) {
      anim += dT * 6;
    }
    currSize = Math.pow(Math.cos(anim) * 0.5 + 0.5, 4);

    if (x < -100) {
      this.destroyed = true;
    }
    const px = engine.getPlayerX();
    engine.getPlayerY();
    if (px > x - s/2 && px < x + s / 2) {
      if (canHurtPlayer()) {
        bus.emit('hit');
      }
    }
  };
  this.render = (ctx) => {
    ctx.save();
    const s = engine.getScale() * 60;
    const h = engine.laneHeight() * currSize;
    let ty = engine.topLimit();
    let by = engine.bottomLimit();
    ctx.translate(x, 0);
    if (canHurtPlayer()) {
      ctx.fillStyle='#00f';
    } else {
      ctx.fillStyle='rgba(0,0,255,0.25)';
    }
    ctx.fillRect(-s/2, ty, s, h + 5);
    ctx.fillRect(-s/2, by, s, - 5 - h);
    ctx.restore();
  };
}

function Engine() {
  // Game dimensions
  const railWidth = 0.1;
  const buttonWidth = 0.15;

  // Game state
  let normalTime = true;
  let normalMatter = true;
  let normalSpace = true;
  let anim = 0;
  persist.setDist(0);

  // Game objects
  const player = new Player(this);
  add(player);

  // Touch controls
  bus.on('tap', ({x, y}) => {
    const h = height();
    const w = width();
    const th = h - buttonWidth * h;
    if (y > th && y < h) {
      if (x > 0 && x <= w / 3) {
        normalSpace = !normalSpace;
        bus.emit('space-change');
      }
      if (x > w / 3 && x <= w * 2 / 3) {
        normalMatter = !normalMatter;
        bus.emit('matter-change');
      }
      if (x > w * 2 / 3 && x <= w) {
        normalTime = !normalTime;
        bus.emit('time-change');
      }
    }
  });

  // Game events
  bus.on('hit', () => {
    persist.setDist(anim);
    transition(3);
  });

  this.getScale = () => {
    return width() / 800.0;
  };

  this.laneHeight = () => {
    const TL = this.topLimit();
    const BL = this.bottomLimit();
    return (BL - TL) / 2;
  };

  this.topLimit = () => {
    let h = height();
    return railWidth * h;
  };

  this.bottomLimit = () => {
    let h = height();
    return h - (railWidth + buttonWidth) * h;
  };

  this.getTickX = (tick) => {
    const w = width();
    return w + tick * w / 3 - anim * w;
  };

  this.getPlayerX = () => { return player.getX(); };
  this.getPlayerY = () => { return player.getY(); };

  this.getLaneY = (lane) => {
    const TL = this.topLimit();
    this.bottomLimit();
    const LW = this.laneHeight();
    return TL + lane * LW + LW/2;
  };

  this.getGravity = () => {
    if (normalMatter) {
      return 1;
    } else {
      return -1;
    }
  };

  this.getStretch = () => {
    return normalSpace;
  };

  this.getTime = () => {
    return normalTime;
  };

  let tickNum = 2;
  const generateObstacles = () => {
    let likelihood = Math.min(0.25 + 1.0 / (tickNum * 0.05), 0.66);
    // Matter wall
    if (Math.random() > likelihood) {
      let lane = 0;
      if (Math.random() > 0.5) {
        lane = 1;
      }
      add(new FixedWall(this, tickNum, lane));
      if (tickNum < 15) {
        tickNum += 1;
        return;
      }
    }

    // Space wall
    if (Math.random() > likelihood) {
      let mode = 0;
      if (Math.random() > 0.5) {
        mode = 1;
      }
      add(new StretchWall(this, tickNum, mode));
      if (tickNum < 15) {
        tickNum += 1;
        return;
      }
    }

    // Time wall
    if (Math.random() > likelihood) {
      add(new TimeWall(this, tickNum, Math.random()));
    }

    tickNum += 1;
  };

  let ticker = 0;
  this.update = (dT) => {
    let rate = 0.3 + (tickNum / 500.0);
    anim += dT * rate;
    ticker += dT * rate * 3;
    if (ticker > 1) {
      generateObstacles();
      ticker -= 1;
    }
  };

  const drawSwitch = (ctx, x, y, s, state) => {
    ctx.fillStyle = '#222';
    ctx.fillRect(x - s, y - s * 1.5, s * 2, s * 3);
    if (state) {
      ctx.fillStyle = '#666';
      ctx.fillRect(x - s*0.6, y - s * 4, s * 1.2, s * 4);
      ctx.beginPath();
      ctx.arc(x, y - s * 4, s, 0, 6.29);
      ctx.fill();
    } else {
      ctx.fillStyle = '#777';
      ctx.fillRect(x - s*0.6, y, s * 1.2, s * 4);
      ctx.beginPath();
      ctx.arc(x, y + s * 4, s, 0, 6.29);
      ctx.fill();
    }
  };

  this.render = (ctx) => {
    // Screen dimensions
    const w = width();
    const h = height();
    const bh = buttonWidth * h;
    const s = Math.min(bh * 0.2, w * 0.04);
    const switchX = w * 0.28;
    const switchY = bh * 0.65;
    const switchSZ = Math.min(w * 0.015, bh * 0.07);

    // Bottom and top rails
    ctx.fillStyle='#000';
    const TL = this.topLimit();
    ctx.fillRect(0, 0, w, TL);
    ctx.fillRect(0, this.bottomLimit(), w, railWidth * h);
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle='#112';
      ctx.fillRect(w - (i * w / 3 + anim * w) % w, 0, 5, TL);
    }

    // Controls area
    ctx.fillStyle='#222';
    ctx.fillRect(0, this.bottomLimit() + railWidth * h, w, bh);

    // Space controls
    ctx.lineWidth = s * 0.3;
    if (normalSpace) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#3a3';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#262';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(0, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.moveTo(w / 6 - s * 1.5, bh * 0.65);
    ctx.lineTo(w / 6 - s * 0.2, bh * 0.65 - s);
    ctx.lineTo(w / 6 - s * 0.2, bh * 0.65 + s);
    ctx.lineTo(w / 6 - s * 1.5, bh * 0.65);
    ctx.moveTo(w / 6 + s * 1.5, bh * 0.65);
    ctx.lineTo(w / 6 + s * 0.2, bh * 0.65 - s);
    ctx.lineTo(w / 6 + s * 0.2, bh * 0.65 + s);
    ctx.lineTo(w / 6 + s * 1.5, bh * 0.65);
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalSpace) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Space', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, true);
    } else {
      ctx.fillStyle = '#777';
      ctx.fillText('Warped Space', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, false);
    }
    ctx.restore();

    // Matter controls
    ctx.lineWidth = s * 0.3;
    if (normalMatter) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#a33';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#622';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(w / 3, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.arc(w / 6, bh * 0.65, s * 1.1, 0, 6.29);
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalMatter) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Matter', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, true);
    } else {
      ctx.fillStyle = '#777';
      ctx.fillText('Anti Matter', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, false);
    }
    ctx.restore();

    // Time controls
    ctx.lineWidth = s * 0.3;
    if (normalTime) {
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#33a';
    } else {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#226';
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    ctx.translate(w * 2 / 3, h - bh);
    ctx.fillRect(0, 0, w / 3, bh);
    ctx.beginPath();
    ctx.moveTo(w / 6 - s, bh * 0.65 - s);
    ctx.lineTo(w / 6 + s, bh * 0.65 - s);
    ctx.lineTo(w / 6 - s, bh * 0.65 + s);
    ctx.lineTo(w / 6 + s, bh * 0.65 + s);
    ctx.closePath();
    ctx.stroke();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${s * 0.8}px monospace`;
    if (normalTime) {
      ctx.fillStyle = '#fff';
      ctx.fillText('Normal Time', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, true);
    } else {
      ctx.fillStyle = '#777';
      ctx.fillText('Paused Time', w / 6, bh * 0.2);
      drawSwitch(ctx, switchX, switchY, switchSZ, false);
    }
    ctx.restore();
  };
}

function GameOver() {

  // Title card
  add(new Text('UNSTABLE EINSTEIN', ()=>width()/2, ()=>height()*0.2, '#77f', 1, 'center'));

  // Game over :(
  add(new Text('Game Over', ()=>width()/2, ()=>height()*0.4, '#f55', 1, 'center'));
  let dist = 1 + parseInt(persist.getDist() * 10);
  add(new Text('Einstein ran ' + dist + ' meters', ()=>width()/2, ()=>height()*0.55, '#f55', 0.4, 'center'));

  // Push to play again
  add(new Text('[ Press to retry ]', ()=>width()/2, ()=>height()*0.8, '#77f', 0.5, 'center'));
  var fn = () => {
    transition(1);
    bus.off('tap', fn);
  };
  bus.on('tap', fn);
}

// Init/Reset game
function init() { bus.emit('scene', 0); }

// Go to scene number
function transition(s) {
  bus.emit('txn');
  // When transition animation done, swap scene and perform fade in
  bus.on('txn-done', () => {
    bus.emit('scene', s);
    add(new transition$1(0.9, false));
  });
  // Start transition animation and stop all updaters
  get().forEach((go) => {go.update=undefined;});
  add(new transition$1(0.4, true));
}

(() => {
  // Scene configuration
  var scene = 0;
  var sceneConfig = (sceneNum) => {
    scene = sceneNum;
    bus.clear();
    bus.on('scene', sceneConfig);
    audio.stopMusic();
    audio.setup();
    clear();

    // [SCENE = 0] MAIN MENU
    if (scene == 0) { add(new MainMenu()); }

    // [SCENE = 1] INSTRUCTION
    if (scene == 1) { add(new Intro()); audio.music(); }

    // [SCENE = 2] GAME
    if (scene == 2) { add(new Engine()); audio.bgRocket(); }

    // [SCENE = 3] LOSE SCREEN
    if (scene == 3) { add(new GameOver()); }
  };

  bus.on('scene', sceneConfig);
})();

isMobile = ()=>/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

window.addEventListener('touchstart', (evt) => {
  evt.stopPropagation();
  bus.emit('tap', { x: evt.touches[0].clientX, y: evt.touches[0].clientY });
});

window.addEventListener('mousedown', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (!isMobile()) { bus.emit('tap', { x: evt.x, y: evt.y });}
});

window.addEventListener('mousemove', (evt) => {
  evt.preventDefault();
  evt.stopPropagation();
  if (isMobile()) {
    bus.emit('move', { x: -1, y: -1 });
  } else {
    bus.emit('move', { x: evt.x, y: evt.y });
  }
});

init();

// Wrap in closure to allow variable minification.
(() => {
  // Game loop
  var lastTime = Date.now();
  var removeQueue = [];
  var noop = () => {};

  var gameloop = () => {
    // Compute frame time in seconds
    var currTime = Date.now();
    var dT = (currTime - lastTime) * 0.001;
    if (dT > 0.3) { dT = 0.3; }

    // Clear frame
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, width(), height());

    // Update, render, and queue game object removal
    removeQueue.length = 0;
    get().forEach((g) => {
      (g.ecs || []).forEach((u) => u(dT));
      (g.update || noop)(dT);
      (g.render || noop)(ctx);
      if (g.destroyed) { removeQueue.push(g); }
    });

    // Remove objects enqueued from before
    removeQueue.forEach((x) => remove(x));

    // Request next frame
    lastTime = currTime;
    requestAnimationFrame(gameloop);
  };
  gameloop();
})();
</script></html>